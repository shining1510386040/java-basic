1.java实现多线程的方式？（3种）
    thread类
    runable接口
    callable接口
2.jdk种的线程池的使用？
    线程池接口ExecutorService
    将任务交给线程池后台执行：
        execute(Runnable)
        submit(Runnable)
        submit(Callable)
        invokeAny(...)
        invokeAll(...)
    面试题：什么情况下线程池ExecutorService会进入拒绝策略？
    回答：线程池的执行原则是，先由核心线程数量的线程执行任务，若任务还在增加，则放入阻塞的任务等待队列
        直到队列已满，当队列满了，会继续创建线程直到达到最大线程数，若还有任务，则不再创建线程进入拒绝策略；
    ThreadPoolExecutor类可设置的参数主要有：
        corePoolSize：核心线程数
        核心线程数，核心线程会一直存活，即使没有任务需要处理。当线程数小于核心线程数时，即使现有的线程空闲，线程池也会优先创建新线程来处理任务，而不是直接交给现有的线程处理。
        核心线程在allowCoreThreadTimeout被设置为true时会超时退出，默认情况下不会退出。
        maxPoolSize：最大线程数
        当线程数大于或等于核心线程，且任务队列已满时，线程池会创建新的线程，直到线程数量达到maxPoolSize。如果线程数已等于maxPoolSize，且任务队列已满，则已超出线程池的处理能力，线程池会拒绝处理任务而抛出异常。
        keepAliveTime：线程空闲等待时间
        当线程空闲时间达到keepAliveTime，该线程会退出，直到线程数量等于corePoolSize。如果allowCoreThreadTimeout设置为true，则所有线程均会退出直到线程数量为0。
        allowCoreThreadTimeout
        是否允许核心线程空闲退出，默认值为false。
        queueCapacity：任务等待队列
        任务队列容量。从maxPoolSize的描述上可以看出，任务队列的容量会影响到线程的变化，因此任务队列的长度也需要恰当的设置。
    线程池按以下行为执行任务
        当线程数小于核心线程数时，创建线程。
        当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。
        当线程数大于等于核心线程数，且任务队列已满
            若线程数小于最大线程数，创建线程
            若线程数等于最大线程数，抛出异常，拒绝任务

     面试题：new thread()使用线程有哪些缺点？
         a. 每次new Thread新建对象性能差。
         b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。
         c. 缺乏更多功能，如定时执行、定期执行、线程中断。
         相比new Thread，Java提供的四种线程池的好处在于：
         a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。
         b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。
         c. 提供定时执行、定期执行、单线程、并发数控制等功能。

3.同步锁（jvm）和锁接口Lock？


